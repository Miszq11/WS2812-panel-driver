F\+B\+Graphics (F\+BG) is a simple C 24, 32 bpp (internal format) graphics library with parallelism and custom rendering backend support (graphics A\+PI agnostic).

The library is only two .c files on most use cases, the renderer agnostic library {\ttfamily fbgraphics.\+c} and one of the rendering backend found in {\ttfamily custom\+\_\+backend} directory.

The library come with five backend (see {\ttfamily custom\+\_\+backend} folder) \+:
\begin{DoxyItemize}
\item a Linux framebuffer rendering backend (with 16 bpp support through 24/32 bpp conversion)
\item Open\+GL backend which use the \href{http://www.glfw.org/}{\texttt{ G\+L\+FW}} library
\item Open\+GL ES 2.\+0 backend for fbdev or Raspberry PI
\item fast dispmanx backend (Video Core IV; Raspberry PI)
\item G\+BA backend (slow due to 24/32 bpp -\/$>$ 16 bpp support, mostly done as a proof of concept for portability on low memory hardware)
\end{DoxyItemize}

Features \+:


\begin{DoxyItemize}
\item Easy to write / use custom rendering backend support flexible enough to target low memory hardware!
\item Cross-\/platform with the G\+L\+FW backend (some examples may need to be adapted to the target OS)
\item Linux framebuffer (fbdev) rendering backend support
\begin{DoxyItemize}
\item Double buffering (with optional page flipping mechanism)
\item 16, 24 (B\+G\+R/\+R\+GB), 32 bpp support
\end{DoxyItemize}
\item G\+BA rendering backend
\item Open\+GL rendering backend through G\+L\+FW
\item Open\+GL ES 2.\+0 rendering backend for Raspberry PI or through fbdev (tested on Nano PI Fire 3 board)
\item dispmanx rendering backend (Video Core IV; Raspberry PI)
\item Optional \+: Full parallelism, execute graphics code on multiple C\+PU cores {\bfseries{with a single function}}
\item Image loading (provided by \href{https://lodev.org/lodepng/}{\texttt{ Lode\+P\+NG}}, \href{http://keyj.emphy.de/nanojpeg/}{\texttt{ Nano\+J\+P\+EG}}, and \href{https://github.com/nothings/stb/blob/master/stb_image.h}{\texttt{ stb\+\_\+image}})
\item Bitmap fonts for drawing texts
\item Bare-\/metal graphics primitive (pixels, rectangles, lines, polygon)
\item Easy to do fading, clipping and screen-\/clearing related effects (motion blur etc.)
\item Drawing calls can be used to render into a specified target buffer such as fbg\+\_\+image etc.
\item Framerate tracking \& display for all cores
\item Lightweight enough to be hackable; adapt to all kinds of needs (and still support parallelism easily)
\end{DoxyItemize}

The library is generic, most functions (including parallel ones) only manipulate buffers and you can build a custom rendering backend pretty easily with few functions call, see the {\ttfamily custom\+\_\+backend} folder.

Doxygen documentation \+: \href{https://grz0zrg.github.io/fbg/}{\texttt{ https\+://grz0zrg.\+github.\+io/fbg/}}\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md15}{}\doxysection{Table of Contents}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md15}

\begin{DoxyItemize}
\item F\+B\+Graphics
\begin{DoxyItemize}
\item \href{\#about}{\texttt{ About}}
\begin{DoxyItemize}
\item \href{\#quickstart}{\texttt{ Quickstart}}
\item \href{\#parallelism}{\texttt{ Parallelism}}
\item \href{\#technical-implementation}{\texttt{ Technical implementation}}
\end{DoxyItemize}
\item \href{\#benchmark}{\texttt{ Benchmark}}
\item \href{\#documentation}{\texttt{ Documentation}}
\item \href{\#building}{\texttt{ Building}}
\item \href{\#Rendering-backend}{\texttt{ Rendering backend}}
\item \href{\#GLFW-backend}{\texttt{ G\+L\+FW backend}}
\item \href{\#OpenGL-ES-2-backend}{\texttt{ Open\+GL ES 2.\+0 backend}}
\item \href{\#screenshots}{\texttt{ Screenshots}}
\item \href{\#license}{\texttt{ License}}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md16}{}\doxysubsection{About}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md16}
F\+B\+Graphics was built to produce fullscreen pixels effects easily (think of Processing-\/like creative coding etc.) with non-\/accelerated framebuffer by leveraging multi-\/core processors, it is a bit like a software G\+PU but much less complex and featured, the initial target platform was a Raspberry PI 3B / Nano\+PI.

F\+B\+Graphics was extended to support any numbers of custom rendering backend; all graphics calls manipulate internal buffers and a simple interface allow to draw the result the way you want to.

F\+B\+Graphics can support low memory hardware such as G\+BA. It should be noted that all internal buffers are manipulated in 24/32 bpp so it has to convert to 16bpp on G\+BA.

An Open\+GL rendering backend which use the \href{http://www.glfw.org/}{\texttt{ G\+L\+FW library}} was created to demonstrate the custom backend feature, it allow to draw the non-\/accelerated FB Graphics buffer into an Open\+GL context through a texture and thus allow to interwine 3D or 2D graphics produced with standard Open\+GL calls with C\+P\+U-\/only graphics produced by F\+B\+Graphics draw calls.

An Open\+GL ES 2.\+0 backend is also available with similar features, it target platforms with support for Open\+GL ES 2.\+0 through fbdev (tested on Nano PI Fire 3 S\+BC) or Raspberry PI dispmanx and similar platforms, it wouldn\textquotesingle{}t be hard to extend this for more Open\+GL ES 2.\+0 platforms...

There is also a dispmanx backend targeting Raspberry PI, it have better performances than the Open\+GL ES 2 backend on this platform and is recommended if you don\textquotesingle{}t need 3D stuff.

F\+B\+Graphics was built so that it is possible to create any number of rendering context using different backend running at the same time while exploiting multi-\/core processors... the content of any rendering context can be transfered into other context through images when calling {\ttfamily fbg\+\_\+draw\+Into}

F\+B\+Graphics framebuffer settings support 16, 24 (B\+G\+R/\+R\+GB), 32 bpp, 16 bpp mode is handled by converting from 24 bpp to 16 bpp upon drawing, page flipping mechanism is disabled in 16 bpp mode, {\bfseries{24 bpp is the fastest mode}}.

F\+B\+Graphics is lightweight and does not intend to be a fully featured graphics library, it provide a limited set of graphics primitive and a small set of useful functions to start doing computer graphics anywhere right away with or without multi-\/core support.

If you want to use the parallelism features with advanced graphics primitives, take a look at great libraries such as \href{http://libgd.github.io/}{\texttt{ libgd}}, \href{https://github.com/adafruit/Adafruit-GFX-Library}{\texttt{ Adafruit G\+FX library}} or even \href{https://imagemagick.org}{\texttt{ Image\+Magick}} which should be easy to integrate.

F\+B\+Graphics is fast but should be used with caution, display bounds checking is not implemented on most primitives, this allow raw performances at the cost of crashs if not careful.

Multi-\/core support is optional and is only enabled when {\ttfamily F\+B\+G\+\_\+\+P\+A\+R\+A\+L\+L\+EL} C definition is present.

F\+B\+Graphics framebuffer backend support a mechanism known as page flipping, it allow fast double buffering by doubling the framebuffer virtual area, it is disabled by default because it is actually slower on some devices. You can enable it with a {\ttfamily fbg\+\_\+fbdev\+Setup} call.

V\+Sync is automatically enabled if supported.

{\bfseries{Note}} \+: F\+B\+Graphics framebuffer backend does not let you setup the framebuffer, it expect the framebuffer to be configured prior launch with a command such as \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{fbset -\/fb /dev/fb0 -\/g 512 240 512 240 24 -\/vsync high}
\DoxyCodeLine{setterm -\/cursor off > /dev/tty0}
\end{DoxyCode}


{\ttfamily fbset} should be available in your package manager.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md17}{}\doxysubsubsection{Framebuffer Quickstart}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md17}
The simplest example (no parallelism, without texts and images) \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <sys/stat.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <signal.h>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "fbg\_fbdev.h"}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "fbgraphics.h"}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} keep\_running = 1;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} int\_handler(\textcolor{keywordtype}{int} dummy) \{}
\DoxyCodeLine{    keep\_running = 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) \{}
\DoxyCodeLine{    signal(SIGINT, int\_handler);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{struct }\mbox{\hyperlink{struct__fbg}{\_fbg}} *fbg = fbg\_fbdevSetup(\textcolor{stringliteral}{"/dev/fb0"}, 0); \textcolor{comment}{// you can also directly use fbg\_fbdevInit(); for "/dev/fb0", last argument mean that will not use page flipping mechanism  for double buffering (it is actually slower on some devices!)}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{        fbg\_clear(fbg, 0); \textcolor{comment}{// can also be replaced by fbg\_fill(fbg, 0, 0, 0);}}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_draw(fbg);}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_rect(fbg, fbg-\/>\mbox{\hyperlink{struct__fbg_a1d3c76643e4ee424f4d17e27991d5e2e}{width}} / 2 -\/ 32, fbg-\/>\mbox{\hyperlink{struct__fbg_a3a3bd409e71d020fa77f69a541d832f8}{height}} / 2 -\/ 32, 16, 16, 0, 255, 0);}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_pixel(fbg, fbg-\/>\mbox{\hyperlink{struct__fbg_a1d3c76643e4ee424f4d17e27991d5e2e}{width}} / 2, fbg-\/>\mbox{\hyperlink{struct__fbg_a3a3bd409e71d020fa77f69a541d832f8}{height}} / 2, 255, 0, 0);}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_flip(fbg);}
\DoxyCodeLine{}
\DoxyCodeLine{    \} \textcolor{keywordflow}{while} (keep\_running);}
\DoxyCodeLine{}
\DoxyCodeLine{    fbg\_close(fbg);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


A simple quickstart example with most features (but no parallelism, see below) \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <sys/stat.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <signal.h>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "fbg\_fbdev.h"}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "fbgraphics.h"}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} keep\_running = 1;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} int\_handler(\textcolor{keywordtype}{int} dummy) \{}
\DoxyCodeLine{    keep\_running = 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[]) \{}
\DoxyCodeLine{    signal(SIGINT, int\_handler);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{struct }\mbox{\hyperlink{struct__fbg}{\_fbg}} *fbg = fbg\_fbdevInit();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{struct }\mbox{\hyperlink{struct__fbg__img}{\_fbg\_img}} *texture = fbg\_loadImage(fbg, \textcolor{stringliteral}{"texture.png"});}
\DoxyCodeLine{    \textcolor{keyword}{struct }\mbox{\hyperlink{struct__fbg__img}{\_fbg\_img}} *bb\_font\_img = fbg\_loadImage(fbg, \textcolor{stringliteral}{"bbmode1\_8x8.png"});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keyword}{struct }\mbox{\hyperlink{struct__fbg__font}{\_fbg\_font}} *bbfont = fbg\_createFont(fbg, bb\_font\_img, 8, 8, 33);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{        fbg\_clear(fbg, 0);}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_draw(fbg);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// you can also use fbg\_image(fbg, texture, 0, 0)}}
\DoxyCodeLine{        \textcolor{comment}{// but you must be sure that your image size fit on the display}}
\DoxyCodeLine{        fbg\_imageClip(fbg, texture, 0, 0, 0, 0, fbg-\/>\mbox{\hyperlink{struct__fbg_a1d3c76643e4ee424f4d17e27991d5e2e}{width}}, fbg-\/>\mbox{\hyperlink{struct__fbg_a3a3bd409e71d020fa77f69a541d832f8}{height}});}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_write(fbg, \textcolor{stringliteral}{"Quickstart example\(\backslash\)nFPS:"}, 4, 2);}
\DoxyCodeLine{        fbg\_write(fbg, fbg-\/>\mbox{\hyperlink{struct__fbg_af447e6ed58d893989c8dad075807a79b}{fps\_char}}, 32 + 8, 2 + 8);}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_rect(fbg, fbg-\/>\mbox{\hyperlink{struct__fbg_a1d3c76643e4ee424f4d17e27991d5e2e}{width}} / 2 -\/ 32, fbg-\/>\mbox{\hyperlink{struct__fbg_a3a3bd409e71d020fa77f69a541d832f8}{height}} / 2 -\/ 32, 16, 16, 0, 255, 0);}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_pixel(fbg, fbg-\/>\mbox{\hyperlink{struct__fbg_a1d3c76643e4ee424f4d17e27991d5e2e}{width}} / 2, fbg-\/>\mbox{\hyperlink{struct__fbg_a3a3bd409e71d020fa77f69a541d832f8}{height}} / 2, 255, 0, 0);}
\DoxyCodeLine{}
\DoxyCodeLine{        fbg\_flip(fbg);}
\DoxyCodeLine{}
\DoxyCodeLine{    \} \textcolor{keywordflow}{while} (keep\_running);}
\DoxyCodeLine{}
\DoxyCodeLine{    fbg\_freeImage(texture);}
\DoxyCodeLine{    fbg\_freeImage(bb\_font\_img);}
\DoxyCodeLine{    fbg\_freeFont(bbfont);}
\DoxyCodeLine{}
\DoxyCodeLine{    fbg\_close(fbg);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


{\bfseries{Note}} \+: Functions like {\ttfamily fbg\+\_\+clear} or {\ttfamily fbg\+\_\+fpixel} are fast functions, there is slower equivalent (but more parametrable) such as {\ttfamily fbg\+\_\+background} or {\ttfamily fbg\+\_\+pixel}, some functions variant also support transparency such as \`{}{\ttfamily fbg\+\_\+pixela} or {\ttfamily fbg\+\_\+recta}.

{\bfseries{Note}} \+: You can generate monospace bitmap fonts to be used with {\ttfamily fbg\+\_\+create\+Font} function by using my \href{https://github.com/grz0zrg/monoBitmapFontCreator}{\texttt{ mono\+Bitmap\+Font\+Creator}} tool available \href{https://fbg-bitmap-font-creator.netlify.com/}{\texttt{ here}}\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md18}{}\doxysubsubsection{Parallelism}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md18}
Exploiting multiple cores with F\+B\+Graphics is really easy, first you have to prepare 3 functions (of which two are optional if you don\textquotesingle{}t have any allocations to do) of the following definition \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// optional function}}
\DoxyCodeLine{\textcolor{keywordtype}{void} *fragmentStart(\textcolor{keyword}{struct} \mbox{\hyperlink{struct__fbg}{\_fbg}} *fbg) \{}
\DoxyCodeLine{    \textcolor{comment}{// typically used to allocate your per-\/thread data}}
\DoxyCodeLine{    \textcolor{comment}{// see full\_example.c for more informations}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} NULL; \textcolor{comment}{// return your user data here}}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} fragment(\textcolor{keyword}{struct} \mbox{\hyperlink{struct__fbg}{\_fbg}} *fbg, \textcolor{keyword}{struct} \mbox{\hyperlink{struct__fragment__user__data}{\_fragment\_user\_data}} *user\_data) \{}
\DoxyCodeLine{    \textcolor{comment}{// this function will be executed by each threads}}
\DoxyCodeLine{    \textcolor{comment}{// you are free to call any FBG graphics primitive here}}
\DoxyCodeLine{    }
\DoxyCodeLine{    fbg\_clear(fbg, 0);}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{// you are also free to fill each threads back buffer the way you want to}}
\DoxyCodeLine{    \textcolor{comment}{// fbg-\/>task\_id : thread identifier (starting at 1, 0 is reserved for the main thread)}}
\DoxyCodeLine{    \textcolor{comment}{// each threads will draw an horizontal line, the shade of the blue color will change based on the thread it is drawn from}}
\DoxyCodeLine{    \textcolor{keywordtype}{int} x = 0, y = 0;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (y = fbg-\/>task\_id; y < fbg-\/>height; y += 4) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (x = 0; x < fbg-\/>\mbox{\hyperlink{struct__fbg_a1d3c76643e4ee424f4d17e27991d5e2e}{width}}; x += 1) \{}
\DoxyCodeLine{            \textcolor{keywordtype}{int} i = (x + y * fbg-\/>\mbox{\hyperlink{struct__fbg_a1d3c76643e4ee424f4d17e27991d5e2e}{width}}) * 3;}
\DoxyCodeLine{            fbg-\/>\mbox{\hyperlink{struct__fbg_a907e7fc97965b972c17114c885e53735}{back\_buffer}}[i] = fbg-\/>task\_id * 85; \textcolor{comment}{// note : BGR format}}
\DoxyCodeLine{            fbg-\/>\mbox{\hyperlink{struct__fbg_a907e7fc97965b972c17114c885e53735}{back\_buffer}}[i + 1] = 0;}
\DoxyCodeLine{            fbg-\/>\mbox{\hyperlink{struct__fbg_a907e7fc97965b972c17114c885e53735}{back\_buffer}}[i + 2] = 0;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{// simple graphics primitive (4 blue rectangle which will be handled by different threads in parallel)}}
\DoxyCodeLine{    fbg\_rect(fbg, fbg-\/>task\_id * 32, 0, 32, 32, 0, 0, 255);}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// optional function}}
\DoxyCodeLine{\textcolor{keywordtype}{void} fragmentStop(\textcolor{keyword}{struct} \mbox{\hyperlink{struct__fbg}{\_fbg}} *fbg, \textcolor{keyword}{struct} \mbox{\hyperlink{struct__fragment__user__data}{\_fragment\_user\_data}} *data) \{}
\DoxyCodeLine{    \textcolor{comment}{// typically used to free your per-\/thread data}}
\DoxyCodeLine{    \textcolor{comment}{// see full\_example.c for more informations}}
\DoxyCodeLine{\}}
\end{DoxyCode}


Then you have to create a \textquotesingle{}Fragment\textquotesingle{} which is a F\+BG multi-\/core task \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{fbg\_createFragment(fbg, fragmentStart, fragment, fragmentStop, 3);}
\end{DoxyCode}


Where \+:


\begin{DoxyItemize}
\item {\ttfamily fbg} is the main library data structure returned by {\ttfamily fbg\+\_\+custom\+Setup} and any backend {\ttfamily fbg\+\_\+backendname\+Setup} calls (see available backends in {\ttfamily custom\+\_\+backend} directory)
\item {\ttfamily fragment\+Start}is a C function which will be executed when the thread start (can be N\+U\+LL)
\item {\ttfamily fragment}is a C function which will be executed indefinitly for each threads and where all the draw code will happen
\item {\ttfamily fragment\+Stop} is a C function which will be executed when the thread end (can be N\+U\+LL)
\item {\ttfamily 3}is the number of parallel tasks (this will launch 3 threads)
\end{DoxyItemize}

And finally you just have to make a call to your fragment function in your drawing loop and call {\ttfamily fbg\+\_\+draw}!


\begin{DoxyCode}{0}
\DoxyCodeLine{fragment(fbg, NULL);}
\DoxyCodeLine{fbg\_draw(fbg, NULL);}
\end{DoxyCode}


{\ttfamily fbg\+\_\+draw} will wait until all the data are received from all the threads then draw to screen

{\bfseries{Note}} \+: This example will use 4 threads (including your app one) for drawing things on the screen but calling the fragment function in your drawing loop is totally optional, you could for example make use of threads for intensive drawing tasks and just use the main thread to draw the G\+UI or the inverse etc. it is up to you!

And that is all you have to do!

See {\ttfamily simple\+\_\+parallel\+\_\+example.\+c} and {\ttfamily full\+\_\+example.\+c} for more informations.

{\bfseries{Note}} \+: By default, the resulting buffer of each tasks are additively mixed into the main back buffer, you can override this behavior by specifying a mixing function as the last argument of {\ttfamily fbg\+\_\+draw} such as \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// function called for each tasks in the fbg\_draw function}}
\DoxyCodeLine{\textcolor{keywordtype}{void} selectiveMixing(\textcolor{keyword}{struct} \mbox{\hyperlink{struct__fbg}{\_fbg}} *fbg, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buffer, \textcolor{keywordtype}{int} task\_id) \{}
\DoxyCodeLine{    \textcolor{comment}{// fbg is the main fbg structure returned by fbg\_customSetup calls and any backend setup calls}}
\DoxyCodeLine{    \textcolor{comment}{// buffer is the current task buffer}}
\DoxyCodeLine{    \textcolor{comment}{// task\_id is the current task id}}
\DoxyCodeLine{    \textcolor{keywordtype}{int} j = 0;}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (j = 0; j < fbg-\/>\mbox{\hyperlink{struct__fbg_a84fb220d4804cba22176997898e75b73}{size}}; j += 1) \{}
\DoxyCodeLine{        fbg-\/>\mbox{\hyperlink{struct__fbg_a907e7fc97965b972c17114c885e53735}{back\_buffer}}[j] = (fbg-\/>\mbox{\hyperlink{struct__fbg_a907e7fc97965b972c17114c885e53735}{back\_buffer}}[j] > buffer[j]) ? fbg-\/>\mbox{\hyperlink{struct__fbg_a907e7fc97965b972c17114c885e53735}{back\_buffer}}[j] : buffer[j];}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\end{DoxyCode}


Then you just have to specify it to the {\ttfamily fbg\+\_\+draw} function \+:


\begin{DoxyCode}{0}
\DoxyCodeLine{fbg\_draw(fbg, additiveMixing);}
\end{DoxyCode}


By using the mixing function, you can have different layers handled by different cores with different compositing rule, see {\ttfamily compositing.\+c} for an example of alpha blending compositing 2 layers running on their own cores.

{\bfseries{Note}} \+: You can only create one Fragment per fbg instance, another call to {\ttfamily fbg\+\_\+create\+Fragment} will stop all tasks for the passed fbg context and will create a new set of tasks.

{\bfseries{Note}} \+: On low performances platforms you may encounter performance issues at high resolution and with a high number of fragments, this is because all the threads buffer need to be mixed back onto the main thread before being displayed and at high resolution / threads count that is alot of pixels to process! You can see an alternative implementation using pure pthread in the {\ttfamily custom\+\_\+backend} folder and {\ttfamily dispmanx\+\_\+pure\+\_\+parallel.\+c} but it doesn\textquotesingle{}t have compositing. If your platform support some sort of S\+I\+MD instructions you could also do all the compositing using S\+I\+MD which should result in a 5x or more speed increase!\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md19}{}\doxysubsubsection{Technical implementation}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md19}
F\+B\+Graphics threads come with their own fbg context data which is essentialy a copy of the actual fbg context, they make use of C atomic types.

Initially parallelism was implemented using \href{http://liblfds.org/}{\texttt{ liblfds}} library for its Ringbuffer and Freelist data structure.

Now parallelism has two implementation, liblfds and a custom synchronization mechanism which has the advantage to not require additional libraries and thus execute on more platforms.

You can still use the liblfds implementation using the {\ttfamily F\+B\+G\+\_\+\+L\+F\+DS} define, it may be faster.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md20}{}\doxyparagraph{With liblfds}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md20}
Each threads begin by fetching a pre-\/allocated buffer from a freelist, then the fragment function is called to fill that buffer, the thread then place the buffer into a ringbuffer data structure which will be fetched upon calling {\ttfamily fbg\+\_\+draw}, the buffers are then mixed into the main back buffer and put back into the freelist.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md21}{}\doxyparagraph{Without liblfds}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md21}
Each threads fragment function is called to fill the local buffer, each threads then wait till that buffer is consumed by the main thread upon calling {\ttfamily fbg\+\_\+draw}, the buffers are then mixed into the main back buffer and {\ttfamily fbg\+\_\+draw} wake up all threads.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md22}{}\doxysubsection{Benchmark (framebuffer)}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md22}
A simple unoptimized per pixels screen clearing with 4 cores on a Raspberry PI 3B \+: 30 F\+PS @ 1280x768 and 370 F\+PS @ 320x240

Note \+: Using the dispmanx backend a screen clearing + rectangle moving on a Raspberry PI 3B \+: 60 F\+PS @ 1920x1080\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md23}{}\doxysubsubsection{Full example}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md23}
Fullscreen per pixels perlin noise with texture mapping and scrolling (unoptimized)

{\bfseries{Device}} \+: Raspberry PI 3B ( Quad Core 1.\+2\+G\+Hz )

{\bfseries{Settings}} \+: 320x240

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Cores used to draw graphics }&\cellcolor{\tableheadbgcolor}\textbf{ F\+PS  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Cores used to draw graphics }&\cellcolor{\tableheadbgcolor}\textbf{ F\+PS  }\\\cline{1-2}
\endhead
1 &42 F\+PS  \\\cline{1-2}
2 &81 F\+PS  \\\cline{1-2}
3 &120 F\+PS  \\\cline{1-2}
\end{longtabu}


See screenshots below.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md24}{}\doxysubsubsection{Tunnel example}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md24}
Fullscreen texture-\/mapped and animated tunnel made of 40800 2px rectangles with motion blur (unoptimized)

{\bfseries{Device}} \+: Raspberry PI 3B ( Quad Core 1.\+2\+G\+Hz )

{\bfseries{Settings}} \+: 320x240

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Cores used to draw graphics }&\cellcolor{\tableheadbgcolor}\textbf{ F\+PS  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Cores used to draw graphics }&\cellcolor{\tableheadbgcolor}\textbf{ F\+PS  }\\\cline{1-2}
\endhead
1 &36 F\+PS  \\\cline{1-2}
2 &69 F\+PS  \\\cline{1-2}
3 &99 F\+PS  \\\cline{1-2}
4 &66 F\+PS  \\\cline{1-2}
\end{longtabu}


Note \+: The framerate drop with 4 cores is due to the main thread being too busy which make all the other threads follow due to the synchronization.

See screenshots below.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md25}{}\doxysubsection{Documentation}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md25}
All usable functions and structures are documented in the {\ttfamily \mbox{\hyperlink{fbgraphics_8h_source}{fbgraphics.\+h}}} file with \href{http://www.stack.nl/~dimitri/doxygen/}{\texttt{ Doxygen}}

The H\+T\+ML documentation can be found in the {\ttfamily docs} directory, it is also hosted on Git\+Hub \href{https://grz0zrg.github.io/fbg/}{\texttt{ here}}

Examples demonstrating all features are available in the {\ttfamily examples} directory.

Some effects come from \href{https://www.openprocessing.org/user/130883\#sketches}{\texttt{ my Open Processing sketches}}\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md26}{}\doxysubsection{Building}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md26}
C11 standard should be supported by the C compiler.

All examples found in {\ttfamily examples} directory make use of the framebuffer device {\ttfamily /dev/fb0} and can be built by typing {\ttfamily make} into the examples directory then run them by typing {\ttfamily ./run\+\_\+quickstart} for example (this handle the framebuffer setup prior launch), you will need to compile liblfds for the parallelism features. (see below)

All examples were tested on a Raspberry PI 3B with framebuffer settings \+: 320x240 24 bpp

For the default build (no parallelism), F\+B\+Graphics come with a header file {\ttfamily \mbox{\hyperlink{fbgraphics_8h_source}{fbgraphics.\+h}}} and a C file {\ttfamily fbgraphics.\+c} to be included / compiled / linked with your program plus one of the rendering backend found in {\ttfamily custom\+\_\+backend} directory, you will also need to compile the {\ttfamily lodepng.\+c} library and {\ttfamily nanojpeg.\+c} library, see the examples directory for examples of Makefile.

For parallelism support, {\ttfamily F\+B\+G\+\_\+\+P\+A\+R\+A\+L\+L\+EL} need to be defined.

If you need to use the slightly different parallelism implementation (see technical implementation section) you will need the \href{http://liblfds.org/}{\texttt{ liblfds}} library \+:


\begin{DoxyItemize}
\item Get latest liblfds 7.\+1.\+1 package on the official website
\item uncompress, go into the directory {\ttfamily liblfds711}
\item go into the directory {\ttfamily build/gcc\+\_\+gnumake}
\item type {\ttfamily make} in a terminal
\item {\ttfamily liblfds711.\+a} can now be found in the {\ttfamily bin} directory, you need to link against it when compiling (see examples)
\end{DoxyItemize}

To compile liblfds parallel examples, just copy {\ttfamily liblfds711.\+a} / {\ttfamily liblfds711.\+h} file and {\ttfamily liblfds711} directory into the {\ttfamily examples} directory then type {\ttfamily make lfds711}.

{\bfseries{Note}} \+: F\+B\+Graphics with liblfds work on A\+R\+M64 platforms but you will need liblfds720 which is not yet released.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md27}{}\doxysubsubsection{Executable size optimization}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md27}
This library may be used for size optimized executable for things like \href{https://en.wikipedia.org/wiki/Demoscene}{\texttt{ demos}}

Image support can be disabled with the following defines\+:
\begin{DoxyItemize}
\item {\ttfamily W\+I\+T\+H\+O\+U\+T\+\_\+\+J\+P\+EG}
\item {\ttfamily W\+I\+T\+H\+O\+U\+T\+\_\+\+P\+NG}
\item {\ttfamily W\+I\+T\+H\+O\+U\+T\+\_\+\+S\+T\+B\+\_\+\+I\+M\+A\+GE}
\end{DoxyItemize}

See {\ttfamily tiny} makefile rule inside the {\ttfamily custom\+\_\+backend} or {\ttfamily examples} folder for some compiler optimizations related to executable size.

Under Linux \href{https://github.com/BR903/ELFkickers/tree/master/sstrip}{\texttt{ sstrip}} and \href{https://upx.github.io/}{\texttt{ U\+PX}} can be used to bring the size down even futher.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md28}{}\doxysubsection{Rendering backend}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md28}
See {\ttfamily R\+E\+A\+D\+ME} into {\ttfamily custom\+\_\+backend} folder\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md29}{}\doxysubsection{G\+L\+F\+W backend}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md29}
See {\ttfamily R\+E\+A\+D\+ME} into {\ttfamily custom\+\_\+backend} folder

The G\+L\+FW backend was made to demonstrate how to write a backend but it is complete enough to be used by default.

The G\+L\+FW backend has a cool lightweight Lua example which setup a Processing-\/like environment making use of the parallelism feature of the library, allowing the user to prototype multithreaded graphical stuff without C code compilation through the Lua language.\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md30}{}\doxysubsection{Open\+G\+L E\+S 2 backend}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md30}
See {\ttfamily R\+E\+A\+D\+ME} into {\ttfamily custom\+\_\+backend} folder\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md31}{}\doxysubsection{G\+B\+A backend}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md31}
See {\ttfamily R\+E\+A\+D\+ME} into {\ttfamily custom\+\_\+backend} folder\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md32}{}\doxysubsection{Screenshots}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md32}








\hypertarget{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md33}{}\doxysubsection{License}\label{md__home_andrzej_Programowanie_SWIS_WS2812-panel-driver_external_module_app_src_external_fbg_README_autotoc_md33}
B\+SD, see L\+I\+C\+E\+N\+SE file 