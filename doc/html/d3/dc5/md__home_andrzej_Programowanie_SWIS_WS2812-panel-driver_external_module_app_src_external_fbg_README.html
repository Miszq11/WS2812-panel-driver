<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WS2812 panel driver: FBGraphics : Lightweight C 2D graphics API agnostic library with parallelism support</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WS2812 panel driver
   </div>
   <div id="projectbrief">WS2812 driver for STM32MP157C-DK2 board using buildroot</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">FBGraphics : Lightweight C 2D graphics API agnostic library with parallelism support </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>FBGraphics (FBG) is a simple C 24, 32 bpp (internal format) graphics library with parallelism and custom rendering backend support (graphics API agnostic).</p>
<p>The library is only two .c files on most use cases, the renderer agnostic library <code>fbgraphics.c</code> and one of the rendering backend found in <code>custom_backend</code> directory.</p>
<p>The library come with five backend (see <code>custom_backend</code> folder) :</p><ul>
<li>a Linux framebuffer rendering backend (with 16 bpp support through 24/32 bpp conversion)</li>
<li>OpenGL backend which use the <a href="http://www.glfw.org/">GLFW</a> library</li>
<li>OpenGL ES 2.0 backend for fbdev or Raspberry PI</li>
<li>fast dispmanx backend (Video Core IV; Raspberry PI)</li>
<li>GBA backend (slow due to 24/32 bpp -&gt; 16 bpp support, mostly done as a proof of concept for portability on low memory hardware)</li>
</ul>
<p>Features :</p>
<ul>
<li>Easy to write / use custom rendering backend support flexible enough to target low memory hardware!</li>
<li>Cross-platform with the GLFW backend (some examples may need to be adapted to the target OS)</li>
<li>Linux framebuffer (fbdev) rendering backend support<ul>
<li>Double buffering (with optional page flipping mechanism)</li>
<li>16, 24 (BGR/RGB), 32 bpp support</li>
</ul>
</li>
<li>GBA rendering backend</li>
<li>OpenGL rendering backend through GLFW</li>
<li>OpenGL ES 2.0 rendering backend for Raspberry PI or through fbdev (tested on Nano PI Fire 3 board)</li>
<li>dispmanx rendering backend (Video Core IV; Raspberry PI)</li>
<li>Optional : Full parallelism, execute graphics code on multiple CPU cores <b>with a single function</b></li>
<li>Image loading (provided by <a href="https://lodev.org/lodepng/">LodePNG</a>, <a href="http://keyj.emphy.de/nanojpeg/">NanoJPEG</a>, and <a href="https://github.com/nothings/stb/blob/master/stb_image.h">stb_image</a>)</li>
<li>Bitmap fonts for drawing texts</li>
<li>Bare-metal graphics primitive (pixels, rectangles, lines, polygon)</li>
<li>Easy to do fading, clipping and screen-clearing related effects (motion blur etc.)</li>
<li>Drawing calls can be used to render into a specified target buffer such as fbg_image etc.</li>
<li>Framerate tracking &amp; display for all cores</li>
<li>Lightweight enough to be hackable; adapt to all kinds of needs (and still support parallelism easily)</li>
</ul>
<p>The library is generic, most functions (including parallel ones) only manipulate buffers and you can build a custom rendering backend pretty easily with few functions call, see the <code>custom_backend</code> folder.</p>
<p>Doxygen documentation : <a href="https://grz0zrg.github.io/fbg/">https://grz0zrg.github.io/fbg/</a></p>
<h1><a class="anchor" id="autotoc_md15"></a>
Table of Contents</h1>
<ul>
<li>FBGraphics<ul>
<li><a href="../../#about">About</a><ul>
<li><a href="../../#quickstart">Quickstart</a></li>
<li><a href="../../#parallelism">Parallelism</a></li>
<li><a href="../../#technical-implementation">Technical implementation</a></li>
</ul>
</li>
<li><a href="../../#benchmark">Benchmark</a></li>
<li><a href="../../#documentation">Documentation</a></li>
<li><a href="../../#building">Building</a></li>
<li><a href="../../#Rendering-backend">Rendering backend</a></li>
<li><a href="../../#GLFW-backend">GLFW backend</a></li>
<li><a href="../../#OpenGL-ES-2-backend">OpenGL ES 2.0 backend</a></li>
<li><a href="../../#screenshots">Screenshots</a></li>
<li><a href="../../#license">License</a></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md16"></a>
About</h2>
<p>FBGraphics was built to produce fullscreen pixels effects easily (think of Processing-like creative coding etc.) with non-accelerated framebuffer by leveraging multi-core processors, it is a bit like a software GPU but much less complex and featured, the initial target platform was a Raspberry PI 3B / NanoPI.</p>
<p>FBGraphics was extended to support any numbers of custom rendering backend; all graphics calls manipulate internal buffers and a simple interface allow to draw the result the way you want to.</p>
<p>FBGraphics can support low memory hardware such as GBA. It should be noted that all internal buffers are manipulated in 24/32 bpp so it has to convert to 16bpp on GBA.</p>
<p>An OpenGL rendering backend which use the <a href="http://www.glfw.org/">GLFW library</a> was created to demonstrate the custom backend feature, it allow to draw the non-accelerated FB Graphics buffer into an OpenGL context through a texture and thus allow to interwine 3D or 2D graphics produced with standard OpenGL calls with CPU-only graphics produced by FBGraphics draw calls.</p>
<p>An OpenGL ES 2.0 backend is also available with similar features, it target platforms with support for OpenGL ES 2.0 through fbdev (tested on Nano PI Fire 3 SBC) or Raspberry PI dispmanx and similar platforms, it wouldn't be hard to extend this for more OpenGL ES 2.0 platforms...</p>
<p>There is also a dispmanx backend targeting Raspberry PI, it have better performances than the OpenGL ES 2 backend on this platform and is recommended if you don't need 3D stuff.</p>
<p>FBGraphics was built so that it is possible to create any number of rendering context using different backend running at the same time while exploiting multi-core processors... the content of any rendering context can be transfered into other context through images when calling <code>fbg_drawInto</code></p>
<p>FBGraphics framebuffer settings support 16, 24 (BGR/RGB), 32 bpp, 16 bpp mode is handled by converting from 24 bpp to 16 bpp upon drawing, page flipping mechanism is disabled in 16 bpp mode, <b>24 bpp is the fastest mode</b>.</p>
<p>FBGraphics is lightweight and does not intend to be a fully featured graphics library, it provide a limited set of graphics primitive and a small set of useful functions to start doing computer graphics anywhere right away with or without multi-core support.</p>
<p>If you want to use the parallelism features with advanced graphics primitives, take a look at great libraries such as <a href="http://libgd.github.io/">libgd</a>, <a href="https://github.com/adafruit/Adafruit-GFX-Library">Adafruit GFX library</a> or even <a href="https://imagemagick.org">ImageMagick</a> which should be easy to integrate.</p>
<p>FBGraphics is fast but should be used with caution, display bounds checking is not implemented on most primitives, this allow raw performances at the cost of crashs if not careful.</p>
<p>Multi-core support is optional and is only enabled when <code>FBG_PARALLEL</code> C definition is present.</p>
<p>FBGraphics framebuffer backend support a mechanism known as page flipping, it allow fast double buffering by doubling the framebuffer virtual area, it is disabled by default because it is actually slower on some devices. You can enable it with a <code>fbg_fbdevSetup</code> call.</p>
<p>VSync is automatically enabled if supported.</p>
<p><b>Note</b> : FBGraphics framebuffer backend does not let you setup the framebuffer, it expect the framebuffer to be configured prior launch with a command such as :</p>
<div class="fragment"><div class="line">fbset -fb /dev/fb0 -g 512 240 512 240 24 -vsync high</div>
<div class="line">setterm -cursor off &gt; /dev/tty0</div>
</div><!-- fragment --><p><code>fbset</code> should be available in your package manager.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Framebuffer Quickstart</h3>
<p>The simplest example (no parallelism, without texts and images) :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;fbg_fbdev.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fbgraphics.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> keep_running = 1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> int_handler(<span class="keywordtype">int</span> dummy) {</div>
<div class="line">    keep_running = 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">    signal(SIGINT, int_handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="../../d5/d3d/struct__fbg.html">_fbg</a> *fbg = fbg_fbdevSetup(<span class="stringliteral">&quot;/dev/fb0&quot;</span>, 0); <span class="comment">// you can also directly use fbg_fbdevInit(); for &quot;/dev/fb0&quot;, last argument mean that will not use page flipping mechanism  for double buffering (it is actually slower on some devices!)</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        fbg_clear(fbg, 0); <span class="comment">// can also be replaced by fbg_fill(fbg, 0, 0, 0);</span></div>
<div class="line"> </div>
<div class="line">        fbg_draw(fbg);</div>
<div class="line"> </div>
<div class="line">        fbg_rect(fbg, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a> / 2 - 32, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">height</a> / 2 - 32, 16, 16, 0, 255, 0);</div>
<div class="line"> </div>
<div class="line">        fbg_pixel(fbg, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a> / 2, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">height</a> / 2, 255, 0, 0);</div>
<div class="line"> </div>
<div class="line">        fbg_flip(fbg);</div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">while</span> (keep_running);</div>
<div class="line"> </div>
<div class="line">    fbg_close(fbg);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>A simple quickstart example with most features (but no parallelism, see below) :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;fbg_fbdev.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;fbgraphics.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> keep_running = 1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> int_handler(<span class="keywordtype">int</span> dummy) {</div>
<div class="line">    keep_running = 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">    signal(SIGINT, int_handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="../../d5/d3d/struct__fbg.html">_fbg</a> *fbg = fbg_fbdevInit();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="../../df/d1f/struct__fbg__img.html">_fbg_img</a> *texture = fbg_loadImage(fbg, <span class="stringliteral">&quot;texture.png&quot;</span>);</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="../../df/d1f/struct__fbg__img.html">_fbg_img</a> *bb_font_img = fbg_loadImage(fbg, <span class="stringliteral">&quot;bbmode1_8x8.png&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="../../d8/d16/struct__fbg__font.html">_fbg_font</a> *bbfont = fbg_createFont(fbg, bb_font_img, 8, 8, 33);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        fbg_clear(fbg, 0);</div>
<div class="line"> </div>
<div class="line">        fbg_draw(fbg);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// you can also use fbg_image(fbg, texture, 0, 0)</span></div>
<div class="line">        <span class="comment">// but you must be sure that your image size fit on the display</span></div>
<div class="line">        fbg_imageClip(fbg, texture, 0, 0, 0, 0, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a>, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">height</a>);</div>
<div class="line"> </div>
<div class="line">        fbg_write(fbg, <span class="stringliteral">&quot;Quickstart example\nFPS:&quot;</span>, 4, 2);</div>
<div class="line">        fbg_write(fbg, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#af447e6ed58d893989c8dad075807a79b">fps_char</a>, 32 + 8, 2 + 8);</div>
<div class="line"> </div>
<div class="line">        fbg_rect(fbg, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a> / 2 - 32, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">height</a> / 2 - 32, 16, 16, 0, 255, 0);</div>
<div class="line"> </div>
<div class="line">        fbg_pixel(fbg, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a> / 2, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">height</a> / 2, 255, 0, 0);</div>
<div class="line"> </div>
<div class="line">        fbg_flip(fbg);</div>
<div class="line"> </div>
<div class="line">    } <span class="keywordflow">while</span> (keep_running);</div>
<div class="line"> </div>
<div class="line">    fbg_freeImage(texture);</div>
<div class="line">    fbg_freeImage(bb_font_img);</div>
<div class="line">    fbg_freeFont(bbfont);</div>
<div class="line"> </div>
<div class="line">    fbg_close(fbg);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Note</b> : Functions like <code>fbg_clear</code> or <code>fbg_fpixel</code> are fast functions, there is slower equivalent (but more parametrable) such as <code>fbg_background</code> or <code>fbg_pixel</code>, some functions variant also support transparency such as `<code>fbg_pixela</code> or <code>fbg_recta</code>.</p>
<p><b>Note</b> : You can generate monospace bitmap fonts to be used with <code>fbg_createFont</code> function by using my <a href="https://github.com/grz0zrg/monoBitmapFontCreator">monoBitmapFontCreator</a> tool available <a href="https://fbg-bitmap-font-creator.netlify.com/">here</a></p>
<h3><a class="anchor" id="autotoc_md18"></a>
Parallelism</h3>
<p>Exploiting multiple cores with FBGraphics is really easy, first you have to prepare 3 functions (of which two are optional if you don't have any allocations to do) of the following definition :</p>
<div class="fragment"><div class="line"><span class="comment">// optional function</span></div>
<div class="line"><span class="keywordtype">void</span> *fragmentStart(<span class="keyword">struct</span> <a class="code" href="../../d5/d3d/struct__fbg.html">_fbg</a> *fbg) {</div>
<div class="line">    <span class="comment">// typically used to allocate your per-thread data</span></div>
<div class="line">    <span class="comment">// see full_example.c for more informations</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> NULL; <span class="comment">// return your user data here</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> fragment(<span class="keyword">struct</span> <a class="code" href="../../d5/d3d/struct__fbg.html">_fbg</a> *fbg, <span class="keyword">struct</span> <a class="code" href="../../d0/d41/struct__fragment__user__data.html">_fragment_user_data</a> *user_data) {</div>
<div class="line">    <span class="comment">// this function will be executed by each threads</span></div>
<div class="line">    <span class="comment">// you are free to call any FBG graphics primitive here</span></div>
<div class="line">    </div>
<div class="line">    fbg_clear(fbg, 0);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// you are also free to fill each threads back buffer the way you want to</span></div>
<div class="line">    <span class="comment">// fbg-&gt;task_id : thread identifier (starting at 1, 0 is reserved for the main thread)</span></div>
<div class="line">    <span class="comment">// each threads will draw an horizontal line, the shade of the blue color will change based on the thread it is drawn from</span></div>
<div class="line">    <span class="keywordtype">int</span> x = 0, y = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (y = fbg-&gt;task_id; y &lt; fbg-&gt;height; y += 4) {</div>
<div class="line">        <span class="keywordflow">for</span> (x = 0; x &lt; fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a>; x += 1) {</div>
<div class="line">            <span class="keywordtype">int</span> i = (x + y * fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a>) * 3;</div>
<div class="line">            fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">back_buffer</a>[i] = fbg-&gt;task_id * 85; <span class="comment">// note : BGR format</span></div>
<div class="line">            fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">back_buffer</a>[i + 1] = 0;</div>
<div class="line">            fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">back_buffer</a>[i + 2] = 0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// simple graphics primitive (4 blue rectangle which will be handled by different threads in parallel)</span></div>
<div class="line">    fbg_rect(fbg, fbg-&gt;task_id * 32, 0, 32, 32, 0, 0, 255);</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// optional function</span></div>
<div class="line"><span class="keywordtype">void</span> fragmentStop(<span class="keyword">struct</span> <a class="code" href="../../d5/d3d/struct__fbg.html">_fbg</a> *fbg, <span class="keyword">struct</span> <a class="code" href="../../d0/d41/struct__fragment__user__data.html">_fragment_user_data</a> *data) {</div>
<div class="line">    <span class="comment">// typically used to free your per-thread data</span></div>
<div class="line">    <span class="comment">// see full_example.c for more informations</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Then you have to create a 'Fragment' which is a FBG multi-core task :</p>
<div class="fragment"><div class="line">fbg_createFragment(fbg, fragmentStart, fragment, fragmentStop, 3);</div>
</div><!-- fragment --><p>Where :</p>
<ul>
<li><code>fbg</code> is the main library data structure returned by <code>fbg_customSetup</code> and any backend <code>fbg_backendnameSetup</code> calls (see available backends in <code>custom_backend</code> directory)</li>
<li><code>fragmentStart</code>is a C function which will be executed when the thread start (can be NULL)</li>
<li><code>fragment</code>is a C function which will be executed indefinitly for each threads and where all the draw code will happen</li>
<li><code>fragmentStop</code> is a C function which will be executed when the thread end (can be NULL)</li>
<li><code>3</code>is the number of parallel tasks (this will launch 3 threads)</li>
</ul>
<p>And finally you just have to make a call to your fragment function in your drawing loop and call <code>fbg_draw</code>!</p>
<div class="fragment"><div class="line">fragment(fbg, NULL);</div>
<div class="line">fbg_draw(fbg, NULL);</div>
</div><!-- fragment --><p><code>fbg_draw</code> will wait until all the data are received from all the threads then draw to screen</p>
<p><b>Note</b> : This example will use 4 threads (including your app one) for drawing things on the screen but calling the fragment function in your drawing loop is totally optional, you could for example make use of threads for intensive drawing tasks and just use the main thread to draw the GUI or the inverse etc. it is up to you!</p>
<p>And that is all you have to do!</p>
<p>See <code>simple_parallel_example.c</code> and <code>full_example.c</code> for more informations.</p>
<p><b>Note</b> : By default, the resulting buffer of each tasks are additively mixed into the main back buffer, you can override this behavior by specifying a mixing function as the last argument of <code>fbg_draw</code> such as :</p>
<div class="fragment"><div class="line"><span class="comment">// function called for each tasks in the fbg_draw function</span></div>
<div class="line"><span class="keywordtype">void</span> selectiveMixing(<span class="keyword">struct</span> <a class="code" href="../../d5/d3d/struct__fbg.html">_fbg</a> *fbg, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> task_id) {</div>
<div class="line">    <span class="comment">// fbg is the main fbg structure returned by fbg_customSetup calls and any backend setup calls</span></div>
<div class="line">    <span class="comment">// buffer is the current task buffer</span></div>
<div class="line">    <span class="comment">// task_id is the current task id</span></div>
<div class="line">    <span class="keywordtype">int</span> j = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (j = 0; j &lt; fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a84fb220d4804cba22176997898e75b73">size</a>; j += 1) {</div>
<div class="line">        fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">back_buffer</a>[j] = (fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">back_buffer</a>[j] &gt; buffer[j]) ? fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">back_buffer</a>[j] : buffer[j];</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then you just have to specify it to the <code>fbg_draw</code> function :</p>
<div class="fragment"><div class="line">fbg_draw(fbg, additiveMixing);</div>
</div><!-- fragment --><p>By using the mixing function, you can have different layers handled by different cores with different compositing rule, see <code>compositing.c</code> for an example of alpha blending compositing 2 layers running on their own cores.</p>
<p><b>Note</b> : You can only create one Fragment per fbg instance, another call to <code>fbg_createFragment</code> will stop all tasks for the passed fbg context and will create a new set of tasks.</p>
<p><b>Note</b> : On low performances platforms you may encounter performance issues at high resolution and with a high number of fragments, this is because all the threads buffer need to be mixed back onto the main thread before being displayed and at high resolution / threads count that is alot of pixels to process! You can see an alternative implementation using pure pthread in the <code>custom_backend</code> folder and <code>dispmanx_pure_parallel.c</code> but it doesn't have compositing. If your platform support some sort of SIMD instructions you could also do all the compositing using SIMD which should result in a 5x or more speed increase!</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Technical implementation</h3>
<p>FBGraphics threads come with their own fbg context data which is essentialy a copy of the actual fbg context, they make use of C atomic types.</p>
<p>Initially parallelism was implemented using <a href="http://liblfds.org/">liblfds</a> library for its Ringbuffer and Freelist data structure.</p>
<p>Now parallelism has two implementation, liblfds and a custom synchronization mechanism which has the advantage to not require additional libraries and thus execute on more platforms.</p>
<p>You can still use the liblfds implementation using the <code>FBG_LFDS</code> define, it may be faster.</p>
<h4><a class="anchor" id="autotoc_md20"></a>
With liblfds</h4>
<p>Each threads begin by fetching a pre-allocated buffer from a freelist, then the fragment function is called to fill that buffer, the thread then place the buffer into a ringbuffer data structure which will be fetched upon calling <code>fbg_draw</code>, the buffers are then mixed into the main back buffer and put back into the freelist.</p>
<h4><a class="anchor" id="autotoc_md21"></a>
Without liblfds</h4>
<p>Each threads fragment function is called to fill the local buffer, each threads then wait till that buffer is consumed by the main thread upon calling <code>fbg_draw</code>, the buffers are then mixed into the main back buffer and <code>fbg_draw</code> wake up all threads.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Benchmark (framebuffer)</h2>
<p>A simple unoptimized per pixels screen clearing with 4 cores on a Raspberry PI 3B : 30 FPS @ 1280x768 and 370 FPS @ 320x240</p>
<p>Note : Using the dispmanx backend a screen clearing + rectangle moving on a Raspberry PI 3B : 60 FPS @ 1920x1080</p>
<h3><a class="anchor" id="autotoc_md23"></a>
Full example</h3>
<p>Fullscreen per pixels perlin noise with texture mapping and scrolling (unoptimized)</p>
<p><b>Device</b> : Raspberry PI 3B ( Quad Core 1.2GHz )</p>
<p><b>Settings</b> : 320x240</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Cores used to draw graphics </th><th class="markdownTableHeadLeft">FPS  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1 </td><td class="markdownTableBodyLeft">42 FPS  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">2 </td><td class="markdownTableBodyLeft">81 FPS  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">3 </td><td class="markdownTableBodyLeft">120 FPS  </td></tr>
</table>
<p>See screenshots below.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
Tunnel example</h3>
<p>Fullscreen texture-mapped and animated tunnel made of 40800 2px rectangles with motion blur (unoptimized)</p>
<p><b>Device</b> : Raspberry PI 3B ( Quad Core 1.2GHz )</p>
<p><b>Settings</b> : 320x240</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Cores used to draw graphics </th><th class="markdownTableHeadLeft">FPS  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">1 </td><td class="markdownTableBodyLeft">36 FPS  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">2 </td><td class="markdownTableBodyLeft">69 FPS  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">3 </td><td class="markdownTableBodyLeft">99 FPS  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">4 </td><td class="markdownTableBodyLeft">66 FPS  </td></tr>
</table>
<p>Note : The framerate drop with 4 cores is due to the main thread being too busy which make all the other threads follow due to the synchronization.</p>
<p>See screenshots below.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Documentation</h2>
<p>All usable functions and structures are documented in the <code><a class="el" href="../../d1/d39/fbgraphics_8h_source.html">fbgraphics.h</a></code> file with <a href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</a></p>
<p>The HTML documentation can be found in the <code>docs</code> directory, it is also hosted on GitHub <a href="https://grz0zrg.github.io/fbg/">here</a></p>
<p>Examples demonstrating all features are available in the <code>examples</code> directory.</p>
<p>Some effects come from <a href="https://www.openprocessing.org/user/130883#sketches">my Open Processing sketches</a></p>
<h2><a class="anchor" id="autotoc_md26"></a>
Building</h2>
<p>C11 standard should be supported by the C compiler.</p>
<p>All examples found in <code>examples</code> directory make use of the framebuffer device <code>/dev/fb0</code> and can be built by typing <code>make</code> into the examples directory then run them by typing <code>./run_quickstart</code> for example (this handle the framebuffer setup prior launch), you will need to compile liblfds for the parallelism features. (see below)</p>
<p>All examples were tested on a Raspberry PI 3B with framebuffer settings : 320x240 24 bpp</p>
<p>For the default build (no parallelism), FBGraphics come with a header file <code><a class="el" href="../../d1/d39/fbgraphics_8h_source.html">fbgraphics.h</a></code> and a C file <code>fbgraphics.c</code> to be included / compiled / linked with your program plus one of the rendering backend found in <code>custom_backend</code> directory, you will also need to compile the <code>lodepng.c</code> library and <code>nanojpeg.c</code> library, see the examples directory for examples of Makefile.</p>
<p>For parallelism support, <code>FBG_PARALLEL</code> need to be defined.</p>
<p>If you need to use the slightly different parallelism implementation (see technical implementation section) you will need the <a href="http://liblfds.org/">liblfds</a> library :</p>
<ul>
<li>Get latest liblfds 7.1.1 package on the official website</li>
<li>uncompress, go into the directory <code>liblfds711</code></li>
<li>go into the directory <code>build/gcc_gnumake</code></li>
<li>type <code>make</code> in a terminal</li>
<li><code>liblfds711.a</code> can now be found in the <code>bin</code> directory, you need to link against it when compiling (see examples)</li>
</ul>
<p>To compile liblfds parallel examples, just copy <code>liblfds711.a</code> / <code>liblfds711.h</code> file and <code>liblfds711</code> directory into the <code>examples</code> directory then type <code>make lfds711</code>.</p>
<p><b>Note</b> : FBGraphics with liblfds work on ARM64 platforms but you will need liblfds720 which is not yet released.</p>
<h3><a class="anchor" id="autotoc_md27"></a>
Executable size optimization</h3>
<p>This library may be used for size optimized executable for things like <a href="https://en.wikipedia.org/wiki/Demoscene">demos</a></p>
<p>Image support can be disabled with the following defines:</p><ul>
<li><code>WITHOUT_JPEG</code></li>
<li><code>WITHOUT_PNG</code></li>
<li><code>WITHOUT_STB_IMAGE</code></li>
</ul>
<p>See <code>tiny</code> makefile rule inside the <code>custom_backend</code> or <code>examples</code> folder for some compiler optimizations related to executable size.</p>
<p>Under Linux <a href="https://github.com/BR903/ELFkickers/tree/master/sstrip">sstrip</a> and <a href="https://upx.github.io/">UPX</a> can be used to bring the size down even futher.</p>
<h2><a class="anchor" id="autotoc_md28"></a>
Rendering backend</h2>
<p>See <code>README</code> into <code>custom_backend</code> folder</p>
<h2><a class="anchor" id="autotoc_md29"></a>
GLFW backend</h2>
<p>See <code>README</code> into <code>custom_backend</code> folder</p>
<p>The GLFW backend was made to demonstrate how to write a backend but it is complete enough to be used by default.</p>
<p>The GLFW backend has a cool lightweight Lua example which setup a Processing-like environment making use of the parallelism feature of the library, allowing the user to prototype multithreaded graphical stuff without C code compilation through the Lua language.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
OpenGL ES 2 backend</h2>
<p>See <code>README</code> into <code>custom_backend</code> folder</p>
<h2><a class="anchor" id="autotoc_md31"></a>
GBA backend</h2>
<p>See <code>README</code> into <code>custom_backend</code> folder</p>
<h2><a class="anchor" id="autotoc_md32"></a>
Screenshots</h2>
<p><img src="../..//screenshot1.png?raw=true" alt="Full example screenshot with three threads" title="Full example screenshot with three threads" class="inline"/></p>
<p><img src="../..//screenshot2.png?raw=true" alt="Tunnel with four threads" title="Tunnel with four threads" class="inline"/></p>
<p><img src="../..//screenshot3.png?raw=true" alt="Earth with four threads" title="Earth with four threads" class="inline"/></p>
<p><img src="../..//screenshot4.png?raw=true" alt="Flags of the world with four threads" title="Flags of the world with four threads" class="inline"/></p>
<p><img src="../..//screenshot5.png?raw=true" alt="Compositing with three threads" title="Compositing with three threads" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md33"></a>
License</h2>
<p>BSD, see LICENSE file </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="astruct__fragment__user__data_html"><div class="ttname"><a href="../../d0/d41/struct__fragment__user__data.html">_fragment_user_data</a></div><div class="ttdef"><b>Definition:</b> dispmanx_parallel.c:15</div></div>
<div class="ttc" id="astruct__fbg_html_a907e7fc97965b972c17114c885e53735"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">_fbg::back_buffer</a></div><div class="ttdeci">unsigned char * back_buffer</div><div class="ttdoc">Back buffer.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:131</div></div>
<div class="ttc" id="astruct__fbg__img_html"><div class="ttname"><a href="../../df/d1f/struct__fbg__img.html">_fbg_img</a></div><div class="ttdoc">Image data structure.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:91</div></div>
<div class="ttc" id="astruct__fbg_html"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html">_fbg</a></div><div class="ttdoc">FB Graphics context data structure.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:123</div></div>
<div class="ttc" id="astruct__fbg_html_a84fb220d4804cba22176997898e75b73"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#a84fb220d4804cba22176997898e75b73">_fbg::size</a></div><div class="ttdeci">int size</div><div class="ttdoc">Framebuffer real data length (with BPP)</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:125</div></div>
<div class="ttc" id="astruct__fbg_html_a1d3c76643e4ee424f4d17e27991d5e2e"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">_fbg::width</a></div><div class="ttdeci">int width</div><div class="ttdoc">Display width in pixels.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:166</div></div>
<div class="ttc" id="astruct__fbg_html_a3a3bd409e71d020fa77f69a541d832f8"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">_fbg::height</a></div><div class="ttdeci">int height</div><div class="ttdoc">Display height in pixels.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:168</div></div>
<div class="ttc" id="astruct__fbg__font_html"><div class="ttname"><a href="../../d8/d16/struct__fbg__font.html">_fbg_font</a></div><div class="ttdoc">Bitmap font data structure.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:103</div></div>
<div class="ttc" id="astruct__fbg_html_af447e6ed58d893989c8dad075807a79b"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#af447e6ed58d893989c8dad075807a79b">_fbg::fps_char</a></div><div class="ttdeci">char fps_char[10]</div><div class="ttdoc">Current FPS as a string.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:191</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
