<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WS2812 panel driver: FBGraphics : Custom rendering backend</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">WS2812 panel driver
   </div>
   <div id="projectbrief">WS2812 driver for STM32MP157C-DK2 board using buildroot</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">FBGraphics : Custom rendering backend </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
OpenGL ES 2.0</h1>
<p>FBG OpenGL ES 2.0 rendering backend with GL utilities, similar to the GLFW backend.</p>
<p>Support rendering through fbdev (tested on Nano PI Fire 3 board) and / or dispmanx on Raspberry PI.</p>
<p>On Nano PI Fire 3 with fbdev we get 20 fps @ 720p without paralellism and 28 fps @ 720p with 7 threads (and the main thread doing nothing but SIMD buffers copy / blitting), compared to 24 fps @ 720p with paralellism but without OpenGL ES 2, main bottleneck with OpenGL ES 2 is due to CPU -&gt; GPU buffer transfer (through <code>glTexSubImage2D</code>),</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Compiling</h2>
<p>See examples <code>makefile</code> <code>rpies2</code> / <code>fbdeves2</code> rule to compile</p>
<p>On Raspberry PI you must define <code>FBG_RPI</code> when compiling, this will enable the use of dispmanx which has some advantages over fbdev.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Examples</h2>
<p>See <code>opengl_es2_example.c</code></p>
<p>See <code>opengl_es2_parallel.c</code></p>
<h1><a class="anchor" id="autotoc_md3"></a>
dispmanx</h1>
<p>FBG dispmanx double buffering rendering backend, allow fast blitting of the software buffers by using Video Core IV GPU (as used in Raspberry PI)</p>
<p>Note : All drawing is still done in software, dispmanx is just used for fast CPU -&gt; GPU buffer transfer aka blitting... the single core example run at full fps at 1920x1080.</p>
<p>Good FBG Parallelism performances is tricky because FBG mix the fragments buffer on the main CPU and at 1080p with 3 threads there is alot of pixels to mix so you get 2 fps at 1080p... the parallel example use another approach by using dispmanx compositing and output at 8 fps at 1920x1080 (and 30 fps at 720p) with 3 threads by doing all the compositing with dispmanx layers, this has some disadvantages since you are more restricted in compositing operations.</p>
<p>Another way to optimize this without doing dispmanx compositing is to simply integrate a simple SIMD / Neon library like <a href="http://ermig1979.github.io/Simd/index.html">this one</a> and let it mix the buffers, i have achieved 15 fps @ 1080p (instead of 2 fps when doing the compositing on CPU without Neon!!!) for the parallel example (with LFDS and 12 fps without) by replacing the mixing function body by one line of code :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fbg_mixing(<span class="keyword">struct</span> <a class="code" href="../../d5/d3d/struct__fbg.html">_fbg</a> *fbg, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">int</span> task_id) {</div>
<div class="line">    SimdOperationBinary8u(buffer, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a> * fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1db77a2ef506723a575644dbc1cfb747">components</a>, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">back_buffer</a>, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a> * fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1db77a2ef506723a575644dbc1cfb747">components</a>, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a>, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">height</a>, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1db77a2ef506723a575644dbc1cfb747">components</a>, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">back_buffer</a>, fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a> * fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1db77a2ef506723a575644dbc1cfb747">components</a>, SimdOperationBinary8uSaturatedAddition);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Another way and probably the fastest way (with SIMD compositing) to do efficient paralellim is to use MMAL / OpenMax so that FBG do zero copy transfer to GPU, you just have to define <code>FBG_MMAL</code> when compiling, it only use dispmanx to get the display resolution, the only disadvantage of that method is that <em>screen tearing may happen because there is no true VSYNC yet</em>.</p>
<p>There is also a pure pthread parallelism example, see <code>dispmanx_pure_parallel.c</code>, each threads are tasked to push specific pixels, it doesn't need to mix buffers, it only use a pthread barrier to keep everything in sync. It run at 20 fps @ 1080p doing a fullscreen color clear, 50 fps @ 1080p without barrier and 60 fps @ 720p. (720p is probably the best compromise resolution / efficiency on RPI)</p>
<p>Note : Examples may have some room for more optimizations, especially in respect to RPI CPU caches.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Compiling</h2>
<p>See examples <code>makefile</code> <code>dispman</code> rule to compile</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Examples</h2>
<p>See <code>dispmanx_example.c</code></p>
<p>See <code>dispmanx_pure_parallel.c</code></p>
<p>See <code>dispmanx_parallel.c</code></p>
<h1><a class="anchor" id="autotoc_md6"></a>
GBA</h1>
<p>Very simple Game Boy Advance backend written as a proof of concept to target low memory hardware. It is slow due to 24/32 bpp -&gt; 16 bpp conversion upon fbg_draw() calls.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Compiling</h2>
<p>There is no makefile provided to compile this example but this can be used as a base (devkitpro / devkitarm) : <a href="https://github.com/JamieDStewart/GBA_VSCode_Basic">GBA_VSCode_Basic</a></p>
<p>Note : May need to define <code>-DWITHOUT_PNG -DWITHOUT_JPEG</code> when compiling, <code>-lm</code> should also be linked.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Examples</h2>
<p>see <code>gba_example.c</code></p>
<h2><a class="anchor" id="autotoc_md9"></a>
Documentation</h2>
<p>See the FB Graphics documentation.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
GLFW</h1>
<p>FBG OpenGL 3.x+ rendering backend with GL utilities, multi-platform, use the <a href="https://www.glfw.org/">GLFW</a> and <a href="http://glew.sourceforge.net/">GLEW</a> library.</p>
<p><b>How it work</b> : An OpenGL texture is updated in real-time with a FB Graphics context content, as such all FB Graphics draw calls work but are handled by the CPU and the resulting frame buffer is handled by the GPU, you are free to call any OpenGL calls and mix software rendered graphics with accelerated graphics.</p>
<p>It is also possible to modify the way the FBG display buffer is rendered through a shader, see the advanced example where the software rendered background is actually the FBG buffer with a fragment shader applied to it.</p>
<p><code>fbg_glfwSetup</code> accept a <a href="https://en.wikipedia.org/wiki/Supersampling">SSAA</a> parameter (last one) which will increase the FB Graphics context resolution by the specified factor (anti-aliasing amount) and downscale the context upon rendering, this is a cheap solution (albeit slow) to <a href="https://en.wikipedia.org/wiki/Anti-aliasing">anti-aliasing</a> and removing jaggies. When using the SSAA parameter <code>fbg-&gt;width</code> and <code>fbg-&gt;height</code> refer to the internal upscaled FBG context, not the window size. To get the window size you must then use:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d1/d74/struct__fbg__glfw__context.html">_fbg_glfw_context</a> *glfw_context = fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#ae3ecac18abee9dedabacaca9bb063bde">user_context</a>;</div>
<div class="line"><span class="comment">// use glfw_context-&gt;width or glfw_context-&gt;height to get display size</span></div>
</div><!-- fragment --><p>Note: The SSAA parameter only increase the FBG context resolution, as such the anti-aliasing will be applied on the FBG context, not the OpenGL context.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Lua example</h2>
<p>The Lua example is an advanced sample which use the <a href="https://www.lua.org/">Lua</a> scripting language (through <a href="http://luajit.org/">LuaJIT</a>) to provide a sort of multithreaded Processing-like (much much less featured) environment with JIT to build FB Graphics graphical sketches from a Lua script without the need to compile any C code.</p>
<p>This use 8 cores, all threads (FBG fragments) have their own Lua state and call the Lua draw() function at each frames.</p>
<p>See <code>sketch.lua</code> and <code>glfw_lua.c</code></p>
<p>It require the LuaJIT library.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Basic usage</h2>
<p>Just call <code>fbg_glfwSetup</code> then any FB Graphics calls can be used.</p>
<p><code>fbg_glfwClear</code> can also be useful (a wrapper to glClear)</p>
<p><code>fbg_glfwShouldClose</code> can be used to know when the window is closed.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
Advanced usage</h2>
<p>This backend has a lightweight OpenGL library which ease some of the most cumbersome things when starting OpenGL projects such as VBO/VAO/FBO creations, shaders loading (from files or strings), textures creation from FBG images, etc.</p>
<p>It also has built-in OpenGL debugging when <code>DEBUG</code> is defined.</p>
<p>The <code>glfw_example_advanced.c</code> demonstrate nearly all features and mix 2D graphics (FBG) with 3D graphics.</p>
<p><img src="../../spooky.png" alt="Spooky" title="Advanced demonstration" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md14"></a>
Simple example</h2>
<p>Draw a red rectangle (handled by CPU) bouncing off the screen borders, see <code>glfw_example</code> and its <code>makefile</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;sys/stat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;math.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;glfw/fbg_glfw.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> keep_running = 1;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> int_handler(<span class="keywordtype">int</span> dummy) {</div>
<div class="line">    keep_running = 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[]) {</div>
<div class="line">    <span class="keyword">struct </span><a class="code" href="../../d5/d3d/struct__fbg.html">_fbg</a> *fbg = fbg_glfwSetup(800, 600, 3, <span class="stringliteral">&quot;glfw example&quot;</span>, 0, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (fbg == NULL) {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">float</span> x = 0, y = 0, velx = 3.4, vely = 3.425;</div>
<div class="line"> </div>
<div class="line">    signal(SIGINT, int_handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        fbg_glfwClear();</div>
<div class="line">        </div>
<div class="line">        fbg_clear(fbg, 0);</div>
<div class="line"> </div>
<div class="line">        fbg_rect(fbg, x, y, 40, 40, 255, 0, 0);</div>
<div class="line"> </div>
<div class="line">        fbg_draw(fbg);</div>
<div class="line">        fbg_flip(fbg);</div>
<div class="line"> </div>
<div class="line">        x += velx;</div>
<div class="line">        y += vely;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (x &lt;= 0 || x &gt; fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">width</a> - 40) {</div>
<div class="line">            velx = -velx;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (y &lt;= 0 || y &gt; fbg-&gt;<a class="code" href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">height</a> - 40) {</div>
<div class="line">            vely = -vely;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">while</span> (keep_running &amp;&amp; !fbg_glfwShouldClose(fbg));</div>
<div class="line"> </div>
<div class="line">    fbg_close(fbg);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="astruct__fbg_html_a907e7fc97965b972c17114c885e53735"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#a907e7fc97965b972c17114c885e53735">_fbg::back_buffer</a></div><div class="ttdeci">unsigned char * back_buffer</div><div class="ttdoc">Back buffer.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:131</div></div>
<div class="ttc" id="astruct__fbg_html"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html">_fbg</a></div><div class="ttdoc">FB Graphics context data structure.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:123</div></div>
<div class="ttc" id="astruct__fbg_html_ae3ecac18abee9dedabacaca9bb063bde"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#ae3ecac18abee9dedabacaca9bb063bde">_fbg::user_context</a></div><div class="ttdeci">void * user_context</div><div class="ttdoc">User-defined context structure.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:215</div></div>
<div class="ttc" id="astruct__fbg__glfw__context_html"><div class="ttname"><a href="../../d1/d74/struct__fbg__glfw__context.html">_fbg_glfw_context</a></div><div class="ttdoc">GLFW wrapper data structure.</div><div class="ttdef"><b>Definition:</b> fbg_glfw.h:37</div></div>
<div class="ttc" id="astruct__fbg_html_a1d3c76643e4ee424f4d17e27991d5e2e"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#a1d3c76643e4ee424f4d17e27991d5e2e">_fbg::width</a></div><div class="ttdeci">int width</div><div class="ttdoc">Display width in pixels.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:166</div></div>
<div class="ttc" id="astruct__fbg_html_a3a3bd409e71d020fa77f69a541d832f8"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#a3a3bd409e71d020fa77f69a541d832f8">_fbg::height</a></div><div class="ttdeci">int height</div><div class="ttdoc">Display height in pixels.</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:168</div></div>
<div class="ttc" id="astruct__fbg_html_a1db77a2ef506723a575644dbc1cfb747"><div class="ttname"><a href="../../d5/d3d/struct__fbg.html#a1db77a2ef506723a575644dbc1cfb747">_fbg::components</a></div><div class="ttdeci">int components</div><div class="ttdoc">Display components amount (3 = 24 BPP / 4 = 32 BPP)</div><div class="ttdef"><b>Definition:</b> fbgraphics.h:172</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
